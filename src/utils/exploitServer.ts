import axios, { AxiosInstance } from "axios";
import { parse } from "node-html-parser";

export { ExploitServer };

// creating an instance requires some asynchronous initialization, so we
// prevent its creation directly and define a factory method instead
class ExploitServer {
  static #isInternalConstructing = false;
  readonly #url;
  readonly #httpClient;

  constructor(url: string | URL, httpClient: AxiosInstance) {
    if (!ExploitServer.#isInternalConstructing) {
      throw new TypeError(`${ExploitServer.name} is not constructable`);
    }
    ExploitServer.#isInternalConstructing = false;
    this.#url = url;
    this.#httpClient = httpClient;
  }

  async storeExploit(body: string) {
    console.log("storing the exploit on the server...");
    await this.#httpClient.request({
      url: this.#url.toString(),
      method: "post",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
      },
      data: new URLSearchParams({
        urlIsHttps: "on",
        responseFile: "/exploit",
        responseHead:
          "HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8",
        responseBody: body,
        formAction: "STORE",
      }),
    });
  }

  get url() {
    return this.#url;
  }

  static async #getExploitServerLink(labUrl: string | URL) {
    const { data } = await axios.get(labUrl.toString());
    const htmlElement = parse(data).querySelector("#exploit-link");
    if (!htmlElement) {
      throw new Error(
        `Looks like you've already solved the lab and the exploit link isn't available through the lab link`,
      );
    }

    return htmlElement.getAttribute("href") as string;
  }

  static async create(labUrl: string | URL, httpClient: AxiosInstance) {
    ExploitServer.#isInternalConstructing = true;
    const url = await ExploitServer.#getExploitServerLink(labUrl);
    return new ExploitServer(url.toString(), httpClient);
  }
}
